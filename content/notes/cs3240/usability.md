---
title: "Usability"
weight: 6
---

Making an application usable is important. This seems self-evident, but people mess this up all the time.

An important note: *People approach usability with established mental models.* You have schemata in your brain saying, "This is what this thing does." This is true for software, and you need to lean into those schemata if you don't want to confuse people.

We want software that is:

* **Effective** -- it gets the job done
* **Efficient** -- it's not hard to use
* **Engaging** -- the user actually wants to use it
* **Easy to learn** -- it's not hard to learn
* **Error tolerant** -- it's not hard to recover from errors

## User-Centered Design

**User-centered design** is design that is, well, centered around the user. It is important to take the users and their needs into account when designing software.

Elements of user-centered design include:

* **Persona**
  * Who are the users?
  * What do they know?
  * What is their motivation?
* **Scenario**
  * What do they want to do?
  * What else are they doing/thinking?
  * What are their expectations of the system?

## Nielsen's Usability Heuristics

**Heuristics** are rules of thumb that are useful for guiding design. They are not hard-and-fast rules, but they are useful for thinking about design. **Nielsen's usability heuristics** are a set of heuristics that are useful for thinking about usability.

1. **Match between system and the real world.** Users are coming into this with established mental models, often from the real world. If your system doesn't match those mental models, it will be hard to use.
2. **Consistency and standards.** Users expect consistency. For example, the "Save" button is generally under the "File" menu. Keep the "Save" button under the "File" menu.
3. **Help and documentation.** Provide basic help in your application. Let users know how to perform basic functionality.
4. **User control and function.** Users should have control over the system. They should be able to undo actions, and they should be able to control the flow of the system. Give them decision-making power before doing anything critical.
5. **Visibility of system status.** Users should be able to see what is going on in the system. Even little things like gradients in a loading bar let the user know that an operation hasn't stalled.
6. **Flexibility and efficiency of use.** Give features like shortcuts to let users do things quickly. Provide an option to do things in a more efficient way.
7. **Error prevention.** Give good error messages and don't let users do dumb things.
8. **Recognition rather than recall.** A user should be able to look at something and know what it does. Don't make them remember what a button does.
9. **Recognize and diagnose errors.** Make it clear when an error has occurred and explain what it is. Suggest some fixes if you can.
10. **Aesthetic and minimalist design.** More stuff is distracting, so keep the UI as simple as possible. Make it look nice.
